{"ast":null,"code":"import { handleErrors } from '../server';\nimport { randomBytes } from 'crypto';\n\nconst generateToken = () => randomBytes(8).toString('hex');\n\n;\n\nconst login = (schema, req) => {\n  const {\n    username,\n    password\n  } = JSON.parse(req.requestBody);\n  const user = schema.users.findBy({\n    username\n  });\n\n  if (!user) {\n    return handleErrors(null, 'No user with that username exists');\n  }\n\n  if (password !== user.password) {\n    return handleErrors(null, 'Password is incorrect');\n  }\n\n  const token = generateToken();\n  return {\n    user: user.attrs,\n    token\n  };\n};\n\nconst signup = (schema, req) => {\n  const data = JSON.parse(req.requestBody);\n  const exUser = schema.users.findBy({\n    username: data.username\n  });\n\n  if (exUser) {\n    return handleErrors(null, 'A user with that username already exists.');\n  }\n\n  const user = schema.users.create(data);\n  const token = generateToken();\n  return {\n    user: user.attrs,\n    token\n  };\n};\n\nexport default {\n  login,\n  signup\n}; // The login and signup methods here receive a Schema class and a fake Request \n// object and, upon validating the password or checking that the login does not already exist, \n// return the existing user or a new user respectively. We use the Schema object to interact with Mirage’s ORM, \n// while the Request object contains information about the intercepted request including the request body and headers.\n// Next, let’s add methods for working with diaries and diary entries. Create a file named diary.ts in your routes directory:","map":{"version":3,"sources":["C:/Users/Ehsan/Documents/GitHub/React-Diaries-App/src/services/mirage/routes/user.ts"],"names":["handleErrors","randomBytes","generateToken","toString","login","schema","req","username","password","JSON","parse","requestBody","user","users","findBy","token","attrs","signup","data","exUser","create"],"mappings":"AACA,SAASA,YAAT,QAA6B,WAA7B;AAEA,SAASC,WAAT,QAA4B,QAA5B;;AAGA,MAAMC,aAAa,GAAG,MAAMD,WAAW,CAAC,CAAD,CAAX,CAAeE,QAAf,CAAwB,KAAxB,CAA5B;;AAMC;;AAGD,MAAMC,KAAK,GAAG,CAACC,MAAD,EAAcC,GAAd,KAAwD;AACpE,QAAM;AAAEC,IAAAA,QAAF;AAAYC,IAAAA;AAAZ,MAAyBC,IAAI,CAACC,KAAL,CAAWJ,GAAG,CAACK,WAAf,CAA/B;AACA,QAAMC,IAAI,GAAGP,MAAM,CAACQ,KAAP,CAAaC,MAAb,CAAoB;AAAEP,IAAAA;AAAF,GAApB,CAAb;;AACA,MAAI,CAACK,IAAL,EAAW;AACT,WAAOZ,YAAY,CAAC,IAAD,EAAO,mCAAP,CAAnB;AACD;;AACD,MAAIQ,QAAQ,KAAKI,IAAI,CAACJ,QAAtB,EAAgC;AAC9B,WAAOR,YAAY,CAAC,IAAD,EAAO,uBAAP,CAAnB;AACD;;AACD,QAAMe,KAAK,GAAGb,aAAa,EAA3B;AACA,SAAO;AACLU,IAAAA,IAAI,EAAEA,IAAI,CAACI,KADN;AAELD,IAAAA;AAFK,GAAP;AAID,CAdD;;AAiBA,MAAME,MAAM,GAAG,CAACZ,MAAD,EAAcC,GAAd,KAAwD;AACrE,QAAMY,IAAI,GAAGT,IAAI,CAACC,KAAL,CAAWJ,GAAG,CAACK,WAAf,CAAb;AACA,QAAMQ,MAAM,GAAGd,MAAM,CAACQ,KAAP,CAAaC,MAAb,CAAoB;AAAEP,IAAAA,QAAQ,EAAEW,IAAI,CAACX;AAAjB,GAApB,CAAf;;AACA,MAAIY,MAAJ,EAAY;AACV,WAAOnB,YAAY,CAAC,IAAD,EAAO,2CAAP,CAAnB;AACD;;AACD,QAAMY,IAAI,GAAGP,MAAM,CAACQ,KAAP,CAAaO,MAAb,CAAoBF,IAApB,CAAb;AACA,QAAMH,KAAK,GAAGb,aAAa,EAA3B;AACA,SAAO;AACLU,IAAAA,IAAI,EAAEA,IAAI,CAACI,KADN;AAELD,IAAAA;AAFK,GAAP;AAID,CAZD;;AAeA,eAAe;AACbX,EAAAA,KADa;AAEba,EAAAA;AAFa,CAAf,C,CAIA;AACA;AACA;AACA;AACA","sourcesContent":["import { Response, Request } from 'miragejs';\r\nimport { handleErrors } from '../server';\r\nimport { User } from '../../../interfaces/user.interface';\r\nimport { randomBytes } from 'crypto';\r\n\r\n\r\nconst generateToken = () => randomBytes(8).toString('hex');\r\n\r\n\r\nexport interface AuthResponse {\r\n  token: string;\r\n  user: User;\r\n};\r\n\r\n\r\nconst login = (schema: any, req: Request): AuthResponse | Response => {\r\n  const { username, password } = JSON.parse(req.requestBody);\r\n  const user = schema.users.findBy({ username });\r\n  if (!user) {\r\n    return handleErrors(null, 'No user with that username exists');\r\n  }\r\n  if (password !== user.password) {\r\n    return handleErrors(null, 'Password is incorrect');\r\n  }\r\n  const token = generateToken();\r\n  return {\r\n    user: user.attrs as User,\r\n    token,\r\n  };\r\n};\r\n\r\n\r\nconst signup = (schema: any, req: Request): AuthResponse | Response => {\r\n  const data = JSON.parse(req.requestBody);\r\n  const exUser = schema.users.findBy({ username: data.username });\r\n  if (exUser) {\r\n    return handleErrors(null, 'A user with that username already exists.');\r\n  }\r\n  const user = schema.users.create(data);\r\n  const token = generateToken();\r\n  return {\r\n    user: user.attrs as User,\r\n    token,\r\n  };\r\n};\r\n\r\n\r\nexport default {\r\n  login,\r\n  signup,\r\n};\r\n// The login and signup methods here receive a Schema class and a fake Request \r\n// object and, upon validating the password or checking that the login does not already exist, \r\n// return the existing user or a new user respectively. We use the Schema object to interact with Mirage’s ORM, \r\n// while the Request object contains information about the intercepted request including the request body and headers.\r\n// Next, let’s add methods for working with diaries and diary entries. Create a file named diary.ts in your routes directory:"]},"metadata":{},"sourceType":"module"}