{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst diaries = createSlice({\n  name: 'diaries',\n  initialState: [],\n  reducers: {\n    addDiary(state, {\n      payload\n    }) {\n      const diariesToSave = payload.filter(diary => {\n        return state.findIndex(item => item.id === diary.id) === -1;\n      });\n      state.push(...diariesToSave);\n    },\n\n    updateDiary(state, {\n      payload\n    }) {\n      const {\n        id\n      } = payload;\n      const diaryIndex = state.findIndex(diary => diary.id === id);\n\n      if (diaryIndex !== -1) {\n        state.splice(diaryIndex, 1, payload);\n      }\n    }\n\n  }\n});\nexport const {\n  addDiary,\n  updateDiary\n} = diaries.actions;\nexport default diaries.reducer; // The “diaries” property of our state is an array containing the user’s diaries, so our reducer functions \n// here all work on the state object they receive using array methods. Notice here that we are writing normal \n// “mutative” code when working on the state. This is possible because the reducer functions we create using \n// the createSlice() method are wrapped with Immer’s produce() method. This results in Immer returning a correct \n// immutably updated result for our state regardless of us writing mutative code.","map":{"version":3,"sources":["C:/Users/Ehsan/Documents/GitHub/React-Diaries-App/src/features/diary/diariesSlice.ts"],"names":["createSlice","diaries","name","initialState","reducers","addDiary","state","payload","diariesToSave","filter","diary","findIndex","item","id","push","updateDiary","diaryIndex","splice","actions","reducer"],"mappings":"AAAA,SAASA,WAAT,QAA2C,kBAA3C;AAIA,MAAMC,OAAO,GAAGD,WAAW,CAAC;AAC1BE,EAAAA,IAAI,EAAE,SADoB;AAE1BC,EAAAA,YAAY,EAAE,EAFY;AAG1BC,EAAAA,QAAQ,EAAE;AACRC,IAAAA,QAAQ,CAACC,KAAD,EAAQ;AAAEC,MAAAA;AAAF,KAAR,EAA6C;AACnD,YAAMC,aAAa,GAAGD,OAAO,CAACE,MAAR,CAAgBC,KAAD,IAAW;AAC9C,eAAOJ,KAAK,CAACK,SAAN,CAAiBC,IAAD,IAAUA,IAAI,CAACC,EAAL,KAAYH,KAAK,CAACG,EAA5C,MAAoD,CAAC,CAA5D;AACD,OAFqB,CAAtB;AAGAP,MAAAA,KAAK,CAACQ,IAAN,CAAW,GAAGN,aAAd;AACD,KANO;;AAORO,IAAAA,WAAW,CAACT,KAAD,EAAQ;AAAEC,MAAAA;AAAF,KAAR,EAA2C;AACpD,YAAM;AAAEM,QAAAA;AAAF,UAASN,OAAf;AACA,YAAMS,UAAU,GAAGV,KAAK,CAACK,SAAN,CAAiBD,KAAD,IAAWA,KAAK,CAACG,EAAN,KAAaA,EAAxC,CAAnB;;AACA,UAAIG,UAAU,KAAK,CAAC,CAApB,EAAuB;AACrBV,QAAAA,KAAK,CAACW,MAAN,CAAaD,UAAb,EAAyB,CAAzB,EAA4BT,OAA5B;AACD;AACF;;AAbO;AAHgB,CAAD,CAA3B;AAqBA,OAAO,MAAM;AAAEF,EAAAA,QAAF;AAAYU,EAAAA;AAAZ,IAA4Bd,OAAO,CAACiB,OAA1C;AACP,eAAejB,OAAO,CAACkB,OAAvB,C,CACA;AACA;AACA;AACA;AACA","sourcesContent":["import { createSlice, PayloadAction } from '@reduxjs/toolkit';\r\nimport { Diary } from '../../interfaces/diary.interface';\r\n\r\n\r\nconst diaries = createSlice({\r\n  name: 'diaries',\r\n  initialState: [] as Diary[],\r\n  reducers: {\r\n    addDiary(state, { payload }: PayloadAction<Diary[]>) {\r\n      const diariesToSave = payload.filter((diary) => {\r\n        return state.findIndex((item) => item.id === diary.id) === -1;\r\n      });\r\n      state.push(...diariesToSave);\r\n    },\r\n    updateDiary(state, { payload }: PayloadAction<Diary>) {\r\n      const { id } = payload;\r\n      const diaryIndex = state.findIndex((diary) => diary.id === id);\r\n      if (diaryIndex !== -1) {\r\n        state.splice(diaryIndex, 1, payload);\r\n      }\r\n    },\r\n  },\r\n});\r\n\r\n\r\nexport const { addDiary, updateDiary } = diaries.actions;\r\nexport default diaries.reducer;\r\n// The “diaries” property of our state is an array containing the user’s diaries, so our reducer functions \r\n// here all work on the state object they receive using array methods. Notice here that we are writing normal \r\n// “mutative” code when working on the state. This is possible because the reducer functions we create using \r\n// the createSlice() method are wrapped with Immer’s produce() method. This results in Immer returning a correct \r\n// immutably updated result for our state regardless of us writing mutative code."]},"metadata":{},"sourceType":"module"}